<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RouteMaster ONE | Ultimate Waste Collection Router</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        :root{--accent:#0078ff;--dark:#1a1a1a;--bg:#f4f4f9;--text:#333;--white:#fff;--border:#ddd}
        *{box-sizing:border-box}
        body,html{margin:0;padding:0;height:100%;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;overflow:hidden;display:flex;flex-direction:column;background:var(--bg)}
        header{background:var(--dark);color:var(--white);padding:.5rem 1rem;display:flex;justify-content:space-between;align-items:center;box-shadow:0 2px 5px rgba(0,0,0,.2);z-index:1001}
        .logo{font-weight:800;font-size:1.2rem;letter-spacing:-1px}.logo span{color:var(--accent)}
        #stats-ribbon{background:#fff;border-bottom:1px solid var(--border);padding:5px 15px;display:flex;gap:20px;font-size:.85rem;color:#666;overflow-x:auto}
        .stat-val{color:var(--dark);font-weight:700}
        #main-container{flex:1;display:flex;flex-direction:column}
        #map{height:60vh;width:100%;background:#e0e0e0}
        #controls{padding:10px;background:var(--white);border-top:1px solid #ccc;display:flex;align-items:center;gap:8px;flex-wrap:wrap;box-shadow:0 -2px 10px rgba(0,0,0,.05);z-index:1000}
        .btn{background:#eee;border:1px solid #ccc;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:.85rem;display:inline-flex;align-items:center;gap:5px;transition:background .2s;color:var(--text);line-height:1}
        .btn:hover:not(:disabled){background:#e0e0e0}
        .btn.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
        .btn.primary:disabled{background:#ccc;border-color:#ccc;cursor:not-allowed;opacity:.6}
        .btn-reset{color:#d93025}
        input[type=file]{display:none}
        #console-footer{background:#222;color:#0f0;font-family:'Courier New',monospace;font-size:.75rem;padding:4px 10px;height:24px;display:flex;align-items:center}
        #settings-overlay{position:fixed;inset:0;background:rgba(0,0,0,.4);display:none;z-index:2000;justify-content:center;align-items:center}
        .drawer{background:#fff;padding:20px;border-radius:8px;width:min(320px,90vw);box-shadow:0 10px 25px rgba(0,0,0,.2);max-height:90vh;overflow-y:auto}
        .drawer h3{margin-top:0}
        .setting-row{margin-bottom:15px;display:flex;justify-content:space-between;align-items:center}
        .toast{position:fixed;bottom:60px;left:50%;transform:translateX(-50%);background:var(--dark);color:#fff;padding:8px 16px;border-radius:20px;font-size:.9rem;display:none;z-index:3000}
        @media(max-width:640px){#stats-ribbon{font-size:.75rem;gap:10px}}
    </style>
</head>
<body>
<header>
    <div class="logo">RouteMaster <span>ONE</span></div>
    <div style="font-size:.7rem;opacity:.7">v2.0 OPTIMIZED</div>
</header>
<div id="stats-ribbon">
    <span>Ways: <span class="stat-val" id="stat-ways">0</span></span>
    <span>Nodes: <span class="stat-val" id="stat-nodes">0</span></span>
    <span>Length: <span class="stat-val" id="stat-dist">0.0 km</span></span>
    <span>Dead-heads: <span class="stat-val" id="stat-dead">0.0 km</span></span>
    <span>U-Turns: <span class="stat-val" id="stat-uturns">0</span></span>
</div>
<div id="main-container">
    <div id="map"></div>
    <div id="controls">
        <label class="btn">üìÅ Load OSM<input type="file" id="osm-input" accept=".osm,.xml"></label>
        <label class="btn">üìé Attach GPX<input type="file" id="gpx-input" accept=".gpx"></label>
        <button class="btn" id="btn-settings">‚öôÔ∏è</button>
        <div style="flex:1"></div>
        <button class="btn" id="btn-export-app">‚¨áÔ∏è Export</button>
        <button class="btn primary" id="btn-download-gpx" disabled>‚Üì Download GPX</button>
        <button class="btn btn-reset" id="btn-reset">üîÑ Reset</button>
    </div>
</div>
<div id="console-footer">Turbo Engine Ready.</div>
<div id="settings-overlay">
    <div class="drawer">
        <h3>Routing Settings</h3>
        <div class="setting-row"><label>Respect Oneways</label><input type="checkbox" id="set-oneways" checked></div>
        <div class="setting-row"><label>Minimize U-turns</label><input type="checkbox" id="set-uturns" checked></div>
        <div class="setting-row">
            <label>Max Dead-head (m)</label>
            <input type="range" id="set-deadhead" min="0" max="200" value="50" step="10">
            <span id="deadhead-val" style="width:40px;text-align:right">50m</span>
        </div>
        <div class="setting-row" id="gpx-mode-container" style="display:none;border-top:1px solid #eee;padding-top:10px;flex-direction:column;align-items:flex-start">
            <label style="font-weight:700;margin-bottom:5px">GPX Overlay Mode</label>
            <select id="gpx-mode" style="width:100%;padding:4px">
                <option value="barrier">Barrier (Cut OSM)</option>
                <option value="extra">Extra Coverage</option>
            </select>
        </div>
        <button class="btn" style="width:100%;margin-top:10px" id="close-settings">Close</button>
    </div>
</div>
<div class="toast" id="toast"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
'use strict';

// Configuration
const CONFIG = {
    circuitColor: '#0078ff',
    deadHeadColor: '#a855f7',
    maxDijkstraDist: 500,
    uTurnThreshold: 135,
    allowedHighways: new Set([
        'residential', 'tertiary', 'secondary', 'primary', 'unclassified',
        'service', 'living_street', 'trunk', 'trunk_link', 'primary_link',
        'secondary_link', 'tertiary_link'
    ]),
    rebuildTimeout: 3600000 // 1 hour
};

// State
const state = {
    map: null,
    graph: null,
    circuit: [],
    circuitLayer: null,
    nodesLookup: new Map(),
    ways: [],
    startId: null,
    lastBuild: 0
};

// DOM elements cache
const DOM = {};

// Utility functions
const Utils = {
    log(msg) {
        DOM.console.textContent = msg;
    },

    toast(msg, duration = 4000) {
        DOM.toast.textContent = msg;
        DOM.toast.style.display = 'block';
        setTimeout(() => DOM.toast.style.display = 'none', duration);
    },

    haversine([lat1, lon1], [lat2, lon2]) {
        const R = 6371e3;
        const toRad = Math.PI / 180;
        const œÜ1 = lat1 * toRad;
        const œÜ2 = lat2 * toRad;
        const ŒîœÜ = (lat2 - lat1) * toRad;
        const ŒîŒª = (lon2 - lon1) * toRad;

        const a = Math.sin(ŒîœÜ / 2) ** 2 + 
                  Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    },

    bearing([lat1, lon1], [lat2, lon2]) {
        const toRad = Math.PI / 180;
        const œÜ1 = lat1 * toRad;
        const œÜ2 = lat2 * toRad;
        const ŒîŒª = (lon2 - lon1) * toRad;

        const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
        const x = Math.cos(œÜ1) * Math.sin(œÜ2) - 
                  Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
        return Math.atan2(y, x) * 180 / Math.PI;
    },

    angleDiff(a1, a2) {
        let diff = Math.abs(a1 - a2);
        return diff > 180 ? 360 - diff : diff;
    }
};

// Priority Queue
class PriorityQueue {
    constructor() {
        this.heap = [];
    }

    push(priority, value) {
        this.heap.push([priority, value]);
        this._bubbleUp(this.heap.length - 1);
    }

    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const result = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._bubbleDown(0);
        return result;
    }

    _bubbleUp(idx) {
        while (idx > 0) {
            const parent = Math.floor((idx - 1) / 2);
            if (this.heap[parent][0] <= this.heap[idx][0]) break;
            [this.heap[parent], this.heap[idx]] = [this.heap[idx], this.heap[parent]];
            idx = parent;
        }
    }

    _bubbleDown(idx) {
        while (true) {
            let smallest = idx;
            const left = 2 * idx + 1;
            const right = 2 * idx + 2;

            if (left < this.heap.length && this.heap[left][0] < this.heap[smallest][0]) {
                smallest = left;
            }
            if (right < this.heap.length && this.heap[right][0] < this.heap[smallest][0]) {
                smallest = right;
            }
            if (smallest === idx) break;

            [this.heap[idx], this.heap[smallest]] = [this.heap[smallest], this.heap[idx]];
            idx = smallest;
        }
    }

    get length() {
        return this.heap.length;
    }
}

// Graph class
class FastGraph {
    constructor() {
        this.adj = new Map();
        this.idx = new Map();
        this.rev = [];
        this.edgeCount = 0;
    }

    addEdge(u, v, dist, wayId, isDeadHead = false) {
        // Get or create indices
        if (!this.idx.has(u)) {
            this.idx.set(u, this.rev.length);
            this.rev.push(u);
        }
        if (!this.idx.has(v)) {
            this.idx.set(v, this.rev.length);
            this.rev.push(v);
        }

        const ui = this.idx.get(u);
        const vi = this.idx.get(v);

        if (!this.adj.has(ui)) {
            this.adj.set(ui, []);
        }

        this.adj.get(ui).push({
            to: vi,
            dist,
            wayId,
            isDeadHead,
            used: false
        });

        this.edgeCount++;
    }

    getDegrees() {
        const inDeg = new Uint32Array(this.rev.length);
        const outDeg = new Uint32Array(this.rev.length);

        this.adj.forEach((edges, u) => {
            outDeg[u] = edges.length;
            edges.forEach(e => inDeg[e.to]++);
        });

        return { inDeg, outDeg };
    }

    getUnbalanced() {
        const { inDeg, outDeg } = this.getDegrees();
        const sources = [];
        const sinks = [];

        for (let i = 0; i < this.rev.length; i++) {
            const diff = outDeg[i] - inDeg[i];
            if (diff > 0) {
                for (let k = 0; k < diff; k++) sinks.push(i);
            } else if (diff < 0) {
                for (let k = 0; k < -diff; k++) sources.push(i);
            }
        }

        return { sources, sinks };
    }

    reset() {
        this.adj.forEach(edges => {
            edges.forEach(e => e.used = false);
        });
    }
}

// Routing engine
const Router = {
    needsRebuild() {
        return performance.now() - state.lastBuild > CONFIG.rebuildTimeout;
    },

    buildGraph() {
        const t0 = performance.now();
        Utils.log('Building graph...');

        const graph = new FastGraph();
        const respectOneways = DOM.oneways.checked;

        for (const way of state.ways) {
            const nodes = way.nodes;
            for (let i = 0; i < nodes.length - 1; i++) {
                const u = nodes[i];
                const v = nodes[i + 1];
                const cu = state.nodesLookup.get(u);
                const cv = state.nodesLookup.get(v);

                if (!cu || !cv) continue;

                const dist = Utils.haversine(cu, cv);
                graph.addEdge(u, v, dist, way.id);
                
                if (!way.oneway) {
                    graph.addEdge(v, u, dist, way.id);
                }
            }
        }

        state.graph = graph;
        state.startId = graph.rev[0];
        state.lastBuild = performance.now();

        Utils.log(`Graph built in ${(performance.now() - t0).toFixed(0)}ms`);
        return graph;
    },

    balanceGraph(maxDeadhead, minimizeUturns) {
        const graph = state.graph;
        const { sources, sinks } = graph.getUnbalanced();

        if (sources.length === 0) return;

        // Build forward adjacency for Dijkstra
        const fwd = new Map();
        graph.adj.forEach((edges, u) => {
            edges.forEach(e => {
                if (!fwd.has(u)) fwd.set(u, []);
                fwd.get(u).push([e.to, e.dist]);
            });
        });

        const used = new Set();

        // Shuffle sources for variety
        sources.sort(() => Math.random() - 0.5);

        for (const source of sources) {
            const result = this._dijkstra(source, sinks, fwd, used, maxDeadhead);
            
            if (!result) continue;

            const { sink, dist, path } = result;

            // Calculate heading score if minimizing U-turns
            let headingScore = 0;
            if (minimizeUturns && path.length >= 2) {
                const sPos = state.nodesLookup.get(graph.rev[source]);
                const tPos = state.nodesLookup.get(graph.rev[sink]);
                const prevIdx = path[path.length - 2];
                const prevPos = state.nodesLookup.get(graph.rev[prevIdx]);

                if (sPos && tPos && prevPos) {
                    const h1 = Utils.bearing(sPos, tPos);
                    const h2 = Utils.bearing(prevPos, tPos);
                    headingScore = Utils.angleDiff(h1, h2);
                }
            }

            graph.addEdge(graph.rev[source], graph.rev[sink], dist, 'deadhead', true);
            used.add(sink);
        }
    },

    _dijkstra(source, sinks, fwd, used, maxDist) {
        const n = state.graph.rev.length;
        const dist = new Float32Array(n).fill(Infinity);
        const prev = new Int32Array(n).fill(-1);
        const pq = new PriorityQueue();

        dist[source] = 0;
        pq.push(0, source);

        let bestSink = -1;
        let bestDist = Infinity;

        while (pq.length > 0) {
            const [d, u] = pq.pop();
            
            if (d > dist[u]) continue;
            if (d > maxDist) break;

            // Check if we found a sink
            if (sinks.includes(u) && !used.has(u)) {
                if (d < bestDist) {
                    bestDist = d;
                    bestSink = u;
                }
            }

            const edges = fwd.get(u);
            if (!edges) continue;

            for (const [v, cost] of edges) {
                const newDist = d + cost;
                if (newDist < dist[v]) {
                    dist[v] = newDist;
                    prev[v] = u;
                    pq.push(newDist, v);
                }
            }
        }

        if (bestSink === -1) return null;

        // Reconstruct path
        const path = [];
        let curr = bestSink;
        while (curr !== -1) {
            path.unshift(curr);
            curr = prev[curr];
        }

        return { sink: bestSink, dist: bestDist, path };
    },

    findEulerianCircuit() {
        const graph = state.graph;
        if (!graph || graph.edgeCount === 0) return;

        graph.reset();

        const stack = [];
        const path = [];
        let curr = graph.idx.get(state.startId) || 0;

        stack.push(curr);

        while (stack.length > 0) {
            const edges = graph.adj.get(curr);
            let found = false;

            if (edges) {
                for (const edge of edges) {
                    if (!edge.used) {
                        edge.used = true;
                        stack.push(curr);
                        curr = edge.to;
                        found = true;
                        break;
                    }
                }
            }

            if (!found) {
                path.push(curr);
                curr = stack.pop();
            }
        }

        path.reverse();
        state.circuit = path.map(i => graph.rev[i]);
    },

    solve() {
        const t0 = performance.now();

        if (!state.graph || this.needsRebuild()) {
            this.buildGraph();
        }

        const maxDeadhead = parseInt(DOM.deadhead.value, 10);
        const minimizeUturns = DOM.uturns.checked;

        this.balanceGraph(maxDeadhead, minimizeUturns);
        this.findEulerianCircuit();
        
        UI.renderCircuit();
        UI.updateStats(performance.now() - t0);
    }
};

// UI functions
const UI = {
    renderCircuit() {
        if (state.circuitLayer) {
            state.map.removeLayer(state.circuitLayer);
            state.circuitLayer = null;
        }

        const coords = state.circuit
            .map(id => state.nodesLookup.get(id))
            .filter(Boolean);

        if (coords.length < 2) return;

        state.circuitLayer = L.polyline(coords, {
            color: CONFIG.circuitColor,
            weight: 6,
            opacity: 0.8,
            interactive: false
        }).addTo(state.map);

        state.map.fitBounds(state.circuitLayer.getBounds(), { padding: [20, 20] });
    },

    updateStats(ms) {
        let ways = 0;
        let totalDist = 0;
        let deadheadDist = 0;

        state.graph.adj.forEach(edges => {
            edges.forEach(e => {
                if (e.isDeadHead) {
                    deadheadDist += e.dist;
                } else {
                    totalDist += e.dist;
                    ways++;
                }
            });
        });

        DOM.statWays.textContent = ways;
        DOM.statNodes.textContent = state.nodesLookup.size;
        DOM.statDist.textContent = (totalDist / 1000).toFixed(2) + ' km';
        DOM.statDead.textContent = (deadheadDist / 1000).toFixed(2) + ' km';
        DOM.statUturns.textContent = this.countUturns();
        DOM.downloadGpx.disabled = false;

        Utils.log(`Route computed in ${ms.toFixed(0)}ms`);
    },

    countUturns() {
        let count = 0;

        for (let i = 1; i < state.circuit.length - 1; i++) {
            const a = state.nodesLookup.get(state.circuit[i - 1]);
            const b = state.nodesLookup.get(state.circuit[i]);
            const c = state.nodesLookup.get(state.circuit[i + 1]);

            if (!a || !b || !c) continue;

            const diff = Utils.angleDiff(
                Utils.bearing(a, b),
                Utils.bearing(b, c)
            );

            if (diff > CONFIG.uTurnThreshold) count++;
        }

        return count;
    }
};

// Event handlers
const Handlers = {
    async loadOSM(e) {
        const file = e.target.files[0];
        if (!file) return;

        try {
            Utils.log('Parsing OSM...');
            const text = await file.text();
            const doc = new DOMParser().parseFromString(text, 'application/xml');

            state.nodesLookup.clear();
            state.ways = [];

            // Parse nodes
            doc.querySelectorAll('node').forEach(node => {
                state.nodesLookup.set(
                    node.id,
                    [parseFloat(node.getAttribute('lat')), parseFloat(node.getAttribute('lon'))]
                );
            });

            const respectOneways = DOM.oneways.checked;

            // Parse ways
            doc.querySelectorAll('way').forEach(way => {
                const tags = {};
                const nodes = [];

                way.querySelectorAll('tag').forEach(tag => {
                    tags[tag.getAttribute('k')] = tag.getAttribute('v');
                });

                // Filter roads
                if (!tags.highway || tags.service === 'driveway') return;
                if (!CONFIG.allowedHighways.has(tags.highway)) return;

                way.querySelectorAll('nd').forEach(nd => {
                    nodes.push(nd.getAttribute('ref'));
                });

                if (nodes.length < 2) return;

                state.ways.push({
                    id: way.getAttribute('id'),
                    nodes,
                    oneway: tags.oneway === 'yes' && respectOneways
                });
            });

            state.lastBuild = 0;
            Router.solve();
            Utils.toast(`Loaded ${state.ways.length} ways`);
        } catch (err) {
            console.error(err);
            Utils.log('Error loading OSM');
            Utils.toast('Failed to parse OSM file');
        }
    },

    loadGPX(e) {
        if (!e.target.files[0]) return;
        DOM.gpxModeContainer.style.display = 'flex';
        Utils.toast('GPX attached. Adjust mode in settings.');
        Utils.log('GPX loaded');
    },

    downloadGPX() {
        if (state.circuit.length === 0) return;

        let gpx = '<?xml version="1.0"?>\n';
        gpx += '<gpx version="1.1" creator="RouteMaster ONE">\n';
        gpx += '<trk><name>Collection Route</name><trkseg>\n';

        state.circuit.forEach(id => {
            const coord = state.nodesLookup.get(id);
            if (coord) {
                gpx += `<trkpt lat="${coord[0]}" lon="${coord[1]}"></trkpt>\n`;
            }
        });

        gpx += '</trkseg></trk>\n</gpx>';

        const blob = new Blob([gpx], { type: 'application/gpx+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'route.gpx';
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
    },

    async exportApp() {
        try {
            const zip = new JSZip();
            zip.file('index.html', document.documentElement.outerHTML);
            zip.file('README.txt', 
                'RouteMaster ONE ‚Äì Professional Waste Routing\n\n' +
                '1. Open index.html\n' +
                '2. Load OSM file\n' +
                '3. Export GPX route\n\n' +
                'MIT License'
            );

            const blob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'RouteMasterONE_portable.zip';
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 1000);
            Utils.toast('App exported successfully');
        } catch (err) {
            console.error(err);
            Utils.toast('Export failed');
        }
    }
};

// Initialization
function init() {
    // Cache DOM elements
    Object.assign(DOM, {
        console: document.getElementById('console-footer'),
        toast: document.getElementById('toast'),
        statWays: document.getElementById('stat-ways'),
        statNodes: document.getElementById('stat-nodes'),
        statDist: document.getElementById('stat-dist'),
        statDead: document.getElementById('stat-dead'),
        statUturns: document.getElementById('stat-uturns'),
        oneways: document.getElementById('set-oneways'),
        uturns: document.getElementById('set-uturns'),
        deadhead: document.getElementById('set-deadhead'),
        deadheadVal: document.getElementById('deadhead-val'),
        downloadGpx: document.getElementById('btn-download-gpx'),
        gpxModeContainer: document.getElementById('gpx-mode-container')
    });

    // Initialize map
    state.map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap'
    }).addTo(state.map);

    // Event listeners
    document.getElementById('osm-input').addEventListener('change', Handlers.loadOSM);
    document.getElementById('gpx-input').addEventListener('change', Handlers.loadGPX);
    document.getElementById('btn-download-gpx').addEventListener('click', Handlers.downloadGPX);
    document.getElementById('btn-export-app').addEventListener('click', Handlers.exportApp);
    document.getElementById('btn-reset').addEventListener('click', () => location.reload());
    document.getElementById('btn-settings').addEventListener('click', () => {
        document.getElementById('settings-overlay').style.display = 'flex';
    });
    document.getElementById('close-settings').addEventListener('click', () => {
        document.getElementById('settings-overlay').style.display = 'none';
    });
    
    DOM.deadhead.addEventListener('input', e => {
        DOM.deadheadVal.textContent = e.target.value + 'm';
    });

    Utils.log('Turbo Engine Ready.');
}

// Start application
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
